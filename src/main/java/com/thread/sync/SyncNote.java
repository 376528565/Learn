package com.thread.sync;

/**
 * @Author: LQL
 * @Date: 2024/06/17
 * @Description:
 */
public class SyncNote {

    /**
     * Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例:锁方法或者类
     * Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。
     * A:通过monitorenter和monitorexit控制对象在执行时锁计数器（status）加1或者减1（0没被线程获取，
     * 重入锁是当线程获取当前对象后status再+1），保证内存可见性是通过JMM内存模型和happens-before（A发生在B之前，那么A的修改对B可见）
     * Synchronized由什么样的缺陷?
     * A：效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时
     * 不灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活
     * 无法知道是否成功获得锁：相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....
     * -----------------
     * Java Lock是怎么弥补这些缺陷的。Synchronized和Lock的对比，和选择?
     * A：
     * lock(): 加锁
     * unlock(): 解锁
     * tryLock(): 尝试获取锁，返回一个boolean值
     * tryLock(long,TimeUtil): 尝试获取锁，可以设置超时
     * ------------------
     * Synchronized在使用时有何注意事项?
     * A：1、作用域不宜过大，影响程序执行速度，2、避免死锁
     * Synchronized修饰的方法在抛出异常时,会释放锁吗?
     * A：会
     * 多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?
     * A：随机的，等待的线程会尝试获取锁，那个尝试获取成功，就获取锁，其他继续等待
     * Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?
     * A；使用Lock及其子类：ReentrantLock
     * 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?
     * A：使用lock灵活控制加锁和释放锁，以及线程的延迟等待获取锁，判断是否能获取锁等机制
     * 什么是锁的升级和降级?
     * ReentrantReadWriteLock支持锁降级：将写锁降级为读锁，提高并发性
     * A：锁的类型基本包含：无锁、偏向锁（偏向第一次获取改对象的线程）、轻量级锁（线程切换后变成轻量级锁，自旋锁和适应性自旋锁）、重量级锁（直接加锁）
     * 什么是JVM里的偏斜锁、轻量级锁、重量级锁?
     * 不同的JDK中对Synchronized有何优化?
     * 偏向锁：减少无竞争情况下的锁开销。
     * 轻量级锁：降低锁竞争不激烈时的开销。
     * 自旋锁和适应性自旋：减少线程阻塞的开销。
     * 锁粗化和锁消除：减少不必要的锁操作。
     * 逃逸分析：消除不必要的锁。
     */



    public static void main(String[] args) {

    }
}
